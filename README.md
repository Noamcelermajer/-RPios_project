# Raspberry Pi 3 Bare Metal OS

This project is a bare metal operating system for the Raspberry Pi 3, written in AArch64 assembly and C. It is designed to be a learning tool for understanding operating system fundamentals and Raspberry Pi hardware specifics. The operating system implements a basic shell, using the mailbox interface to communicate with the VideoCore GPU for output. 


## ðŸš€ Features

This project has a number of unique features:

### 1. Bare Metal Booting and Initial Setup
- Our system starts in AArch64 assembly, executing a detailed boot sequence that sets up the environment, manages the stack, and transitions from EL3 to EL2.

### 2. Exception Handling
- The boot code incorporates handlers for synchronous exceptions, IRQs, FIQs, and system errors, enabling the OS to respond to and manage various hardware and software exceptions, such as division by zero or accessing invalid memory addresses.

### 3. Resource Management
- The kernel efficiently manages computer resources, allowing other programs to use these resources and execute. This encompasses CPU scheduling, device management, and memory allocation.

### 4. Mailbox Interface for GPU Communication
- The system utilizes the mailbox interface to communicate with the VideoCore GPU, permitting the OS to set display properties and manage output functionalities.

### 5. Memory Management
- Our system provides basic memory management features. For example, the bss section of memory, which is used for uninitialized global variables, is zeroed out during boot to prevent undefined behavior. Additionally, the kernel partitions memory into kernel space and user space and oversees swap space or virtual memory on the hard drive.

### 6. Basic Shell and Command Interpretation
- The OS includes a basic shell that provides a simple command interface. This shell leverages the mailbox interface to send output to the GPU. Moreover, the kernel can interpret user input and execute corresponding functions.

### 7. File System Support
- The OS supports the FAT file system, a popular system for removable storage devices. This feature enables the OS to read from and write to SD cards, USB drives, and more. It also manages file permissions, maintains a directory structure for files, and handles file operations like opening, closing, reading, and writing.

### 8. Custom Linker Script
- A custom linker script is used to control the memory layout of the code, specifying where each section of the code should be loaded in memory.

### 9. QEMU Emulation Support
- The system is compatible with local testing via QEMU, an open-source machine emulator and virtualizer. This facilitates a convenient development and testing environment. QEMU allows the running of one or more operating systems using KVM and Xen hypervisors, or just binaries, in an OS environment already installed on the computer.

## Project File Structure
Based on the file structure you provided, here is an overview:

- **OsDev**: This is the root directory of the project. It contains all the source files, header files, build files, the Makefile, and the final OS image. 

    - **src**: This directory contains all the source code files (.c and .S files). These files are compiled to create the OS.
        - `boot.S`: Assembly code for system bootstrap.
        - `kernel.c`: Main kernel code.
        - `mm.S`: Memzero implementation
        - `utils.S`: Assembly utility functions.
        - Other `.c` files: These implement various functionalities, such as delays, FAT filesystem operations, framebuffer handling, mailbox communication, memory operations, UART, power management, printing, SD card operations, shell, standard library functions, and string operations.
        - `linker.ld`: Linker script to control the memory layout of the final OS image.
        - `font.psf`: Contains a font used by the OS.
    
    - **include**: This directory contains all the header files (.h files) used in the project. They provide function prototypes and macros for the source files.
        - `arm`: Contains headers specific to the ARM architecture.
        - `peripherals`: Contains headers for managing peripheral devices.
        - Other `.h` files: These correspond to the .c files in the src directory, providing their function prototypes and macros.
    
    - **build**: This directory contains the intermediate and final build files. 
        - `.o` files: Object files generated from the .c or .S files.
        - `.d` files: Dependency files generated by the compiler.
        - `kernel8.elf`: The linked file that results from linking all the object files.
        - `kernel8.img`: The final OS image that can be loaded onto a Raspberry Pi.
    
    - **Makefile**: A script used by the `make` build automation tool. It describes the dependencies among the source files and the steps to compile and link them to produce the final OS image, `kernel8.img`.

## Prerequisites

To build and run this operating system, you will need:

- A Raspberry Pi 3
- A GCC cross-compiler for AArch64
- QEMU with support for the `raspi3` machine type

## Building

You can build the project using the provided Makefile:

```bash
make
```

This command generates a `kernel8.img` file that can be loaded by the Raspberry Pi bootloader.

## Running

To run the operating system on the Raspberry Pi:

1. Copy the `kernel8.img` file to a SD card.
2. Insert the SD card into your Raspberry Pi.
3. Power on the Raspberry Pi.

To run the operating system in QEMU you can use makefile:

```bash
make run
```

## Code Overview (In Progress)

- The `boot.S` file contains the assembly code for booting up the system and transitioning from EL3 to EL2.

- The `mBox.c` and `mBox.h` files implement the mailbox interface used to communicate with the GPU.

- The `printf` function and basic shell functionality are implemented in the `shell.c` and `shell.h` files. The shell provides a simple command interface, and uses the mailbox interface to send output to the GPU.

- The `linker.ld` script specifies the memory layout of the code.

## Contributing

Contributions to this project are welcome! Please submit a pull request or open an issue to discuss your changes.

## License

This project is released under the MIT license. 
MIT License

Copyright (c) [2020] [Noam Celermajer & Eran Yeruhami]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

